---
layout: post
title:  "Псевдо 3D с помощью Raycasting"
categories: programming
lang: ru
ref: raycast
---

Сегодня мы рассмотрим алгоритм, который был использован в игре Wolfenstein 3D 1992 года, для имитации 3D пространства.

Ray casting можно перевести как "бросание лучей", что хорошо выражает суть алгоритма. Весь
алгоритм сводится к тому, что мы бросаем N-ое количество лучей и на основание расстояния каждого луча (от начала луча до первого препятствия)
отображаем соответствующую вертикальную линию на экране.

Итак, наши действующие лица:
* 2D плоскоcть (карта)
* Игрок который может передвигаться по 2D плоскоcти

Для простоты, карту будем представлять в виде 2-мерного массива 10 на 10 (хотя есть варианты по оптимальнее)  
где 1 - cтена и 0 - пустое место:  
```python
world_map = [
    [1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1]
]
```

Размер "ячейки" возьмем за 80 на 80 пикселей. Так как у нас карта 10x10 ячеек, удобно сделать так, чтобы размер экрана был
800x800(10*80 x 10*80)

Поместим вышеуказанные параметры в словарь `config`:
```python
config = {
    "screen_w" : 800,
    "screen_h" : 800,
    'fps' : 60,
    'tile' : 80
}
colors = {
    'grey' : (220, 220, 220)
	#...
}
```

Базовые вещи, связанные с pygame я опускаю. Cоздав игровой цикл, поместим внутри него функцию, которая будет отрисовывать карту

```python
def draw_map():
    for y in range(len(world_map)):
        for x in range(len(world_map[y])):
            if world_map[y][x] == 1:
				# в координате (x, y), нарисуй квадрат с шириной и высотой config['tile']
                pygame.draw.rect(screen, colors['grey'], \
                    (x * config['tile'], y * config['tile'], config['tile'], config['tile']), 2)
```

Функция `draw_map()` рисует нашу 2D карту из world_map, получается такой вид сверху на наш игровой мир. Данная функция 
отлично показывает, что мы "находимся" в 2D мире.

Давайте же добавим игрока в нашу игру. Для начала создадим для него словарь конфигурации
```python
player_config = {
    'pos_x' : int(config['screen_w'] / 2), # начальная позиция игрока по координате x
    'pos_y' : int(config['screen_h'] / 2), # начальная позиция игрока по координате y
    'angle' : 0, # угол поворота игрока в радианах, 0 - направление прямо на восток как и тригонометрическом круге.
    'speed' : 5  # скорость игрока
}
```

Само игрока можно описать в отдельном классе:
```python
class Player:
    def __init__(self):
        self.pos_x = player_config['pos_x']
        self.pos_y = player_config['pos_y']
        self.angle = player_config['angle']
        self.speed = player_config['speed']

    @property
    def pos(self):
        return (self.pos_x, self.pos_y)

    def movement(self):
        sin = math.sin(self.angle)
        cos = math.cos(self.angle)
        keys = pygame.key.get_pressed()

        #формулы привидения, и тригонометричкский круг на кординтах pygame
        if keys[pygame.K_w]:
            self.pos_x += self.speed * cos
            self.pos_y += self.speed * sin
        if keys[pygame.K_s]:
            self.pos_x += -self.speed * cos
            self.pos_y += -self.speed * sin
        if keys[pygame.K_a]:
            self.pos_x += self.speed * sin
            self.pos_y += -self.speed * cos
        if keys[pygame.K_d]:
            self.pos_x += -self.speed * sin
            self.pos_y += self.speed * cos
        if keys[pygame.K_LEFT]:
            self.angle -= 0.05
        if keys[pygame.K_RIGHT]:
            self.angle += 0.05
```

Самое важное в этом классе метод movement(), давайте рассмотрим как он работает.

Если бы мы делали 2D управление, то все было бы банально: нажали стрелку вниз, увеличили `self.pos_y`. Нажали
стрелку вправо, увеличили `self.pos_x".  
В нашей же псевдо-3D игре, нужно чтоб при нажатии стрелки верх, персонаж шел в направлении куда они смотрит (`self.angle`), а при нажатии
стрелки влево или вправо, персонаж должен двигаться по линии перпендикулярной направлению.

Итак, вначале мы рассчитываем sin и cos угла поворота нашего персонажа. Эти sin и cos, есть нечто иное как вектор направления нашего
персонажа, поэтому нам достаточно растянуть этот вектор умножением на скорость игрока (self.speed), и прибавить полученный вектор,
к вектору нашего местоположения ([self.pos_x, self.pos_y]). Таким образом мы будем двигаться в заданном направлении. 



